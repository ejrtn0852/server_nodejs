1. 클래스는 new 연산자 없이 호출하면 에러가 난다. 하지만 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자함수는 지원하지 않는다.
3. 클래스는 호이스팅이 발생하지 않는것처럼 동작하지만 함수 선언문으로 정의된 생성자함수는 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
5. 클래스의 constructor, prototypeMethod, staticMethod는 모두 프로퍼티 어트리뷰트 열거 값이 false다.

새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다.

클래스는 값으로 사용할 수 있는 일급객체다.

클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.
클래스 몸체에서 정의할 수 있는 메서드는 constructor, prototype,static Method가 있다.

constructor는 인스턴스를 생성하고 초기화하기 위한 특수 메서드이다.
constructor는 이름을 변경할 수 없다.

클래스도 함수 객체 고유의 프로퍼티를 모두 갖고있다.
프로토타입 객체의 constructor 프로퍼티는 클래스 자신을 가리킨다.
이는 클래스가 인스턴스를 생성하는 생성자 함수라는것을 의미한다.

constructor 
1.constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다.
2.constructor 메서드로 해석되는것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가된다.
3.constructor는 클래스내에 최대 한개만 존재할 수 있다.
4.프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다
5.constructor내부에서 return문은 반드시 생략할것.

PrototypeMethod
1.클래스 내부에서 메소드 축약식으로 선언한 메소드는 프로토타입 메소드다.
2.생성자함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이된다.
3.프로토타입 체인은 기존의 모든 객체 생성 방식뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다. 생성자 함수의 역할을 클래스가 할 뿐이다.
클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 메커니즘이다.

Static Method
1.스테틱 메서드는 인스턴스를 호출하지 않아도 호출할 수 있는 메서드를 말한다.
2.정적 메서드는 클래스에 바인딩된 메서드가 된다. 클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드를 소유할 수 있다.
3.정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스를 호출한다.

정적/프로토타입:인스턴스 메서드 차이
1-1
1. 정적메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입체인이 다르다.
2. 정적 메서드는 클래스로 호출하고, 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메소드는 인스턴스 프로토타입을 참조할수 있다.

1-2
1.프로토타입 메서드는 인스턴스로 호출해야 하므로 프로토타입 메서드 내부의 this는 프로토타입 메서드를 호출한 인스턴스를 가리킨다.
2.정적 메서드는 클래스로 호출해야 하므로 정적 메서드 내부의 this는 인스턴스가 아닌 클래스를 가리킨다. 즉, 프로토타입 메서드와 정적 메서드 내부의 this바인딩이 다르다.
3.물론 메서드 내부에서도 this를 사용하지않더라도 프로토타입 메서드로 정의할 수 있다. 하지만 반드시 인스턴스를 생성한 다음 인스턴스로 호출해야하므로 
this를 사용하지 않는 메서드는 정적 메서드로 정의하는것이 좋다.

클래스의 인스턴스 생성과정

인스턴스 생성과 this바인딩
1. 클래스를 호출하면 constructor의 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체 생성, 이 빈 객체가 바로 클래스의 인스턴스다.
2. constructor의 내부 코드가 실행되어 this에 바인딩되어있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프러파티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티값을 초기화한다. constructor가 생략되었다면 이 과정도 생략한다.
3. 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

인스턴스 프로퍼티
1. 인스턴스 프로퍼티는 constructor 내부에서 정의해야한다.
2. 클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가된다.

자바처럼 클래스안에 변수처럼 사용하는것?
1. 클래스 몸체에서 클래스 필드를 정의할 수 있는 클래스 필드 정의 제안은 아직 ECMAscript의 정식 표준 사양으로 승급되지 않았다.
2. 하지만 최신 브라우저와 NodeJS 버전12이상은 표준 사양으로 승급이 확실시되는 이 제안을 선제적으로 미리 구현해놓았다. 
3. 따라서 최신브라우저와 최신 노드js에선 클래스 필드를 클래스 몸체안에 정의할 수 있다.
4. 함수는 일급 객체이므로 함수를 클래스 필드애 할당할 수 있다. 따라서 클래스 필드를 통해 메서드를 정의할 수 있다.

클래스필드와 화살표함수
  클래스 필드에 화살표 함수를 할당하여 화살표  함수 내부의 this가 인스턴스를 가리키게 하는 경우도 있다.


